diff --git a/mythtv/libs/libmythui/mythrender_d3d9.cpp b/mythtv/libs/libmythui/mythrender_d3d9.cpp
index 9afb06c..eacf76d 100644
--- mythtv/libs/libmythui/mythrender_d3d9.cpp
+++ mythtv/libs/libmythui/mythrender_d3d9.cpp
@@ -149,8 +149,8 @@ QRect D3D9Image::GetRect(void)
 MythRenderD3D9::MythRenderD3D9(void)
   : m_d3d(NULL), m_d3dDevice(NULL),
     m_adaptor_fmt(D3DFMT_UNKNOWN),
-    m_videosurface_fmt((D3DFORMAT)MAKEFOURCC('Y','V','1','2')),
-    m_surface_fmt(D3DFMT_A8R8G8B8), m_texture_fmt(D3DFMT_A8R8G8B8),
+    m_videosurface_fmt(D3DFMT_UNKNOWN),
+    m_surface_fmt(D3DFMT_UNKNOWN), m_texture_fmt(D3DFMT_A8R8G8B8),
     m_rect_vertexbuffer(NULL), m_default_surface(NULL), m_current_surface(NULL),
     m_lock(QMutex::Recursive),
     m_blend(true), m_multi_texturing(true), m_texture_vertices(true)
@@ -196,6 +196,7 @@ bool MythRenderD3D9::FormatSupported(D3DFORMAT surface, D3DFORMAT adaptor)
                                           adaptor, 0, D3DRTYPE_SURFACE, surface);
     if (SUCCEEDED(hr))
     {
+        // NB CheckDeviceFormatConversion is not fuly implemented in Wine as of 1.3.6
         hr = m_d3d->CheckDeviceFormatConversion(D3DADAPTER_DEFAULT,
                                                 D3DDEVTYPE_HAL, surface, adaptor);
         if (SUCCEEDED(hr))
@@ -206,7 +207,6 @@ bool MythRenderD3D9::FormatSupported(D3DFORMAT surface, D3DFORMAT adaptor)
 
 static const QString toString(D3DFORMAT fmt)
 {
-    QString res = "Unknown";
     switch (fmt)
     {
         case D3DFMT_A8:
@@ -216,9 +216,8 @@ static const QString toString(D3DFORMAT fmt)
         case D3DFMT_X8R8G8B8:
             return "X8R8G8B8";
         default:
-            return res;
+            return QString().setNum((ulong)fmt,16);
     }
-    return res;
 }
 
 bool MythRenderD3D9::Create(QSize size, HWND window)
@@ -228,7 +227,6 @@ bool MythRenderD3D9::Create(QSize size, HWND window)
     typedef LPDIRECT3D9 (WINAPI *LPFND3DC)(UINT SDKVersion);
     static  HINSTANCE hD3DLib            = NULL;
     static  LPFND3DC  OurDirect3DCreate9 = NULL;
-    D3DCAPS9 d3dCaps;
 
     if (!hD3DLib)
     {
@@ -256,12 +254,12 @@ bool MythRenderD3D9::Create(QSize size, HWND window)
         return false;
     }
 
+    D3DCAPS9 d3dCaps;
     ZeroMemory(&d3dCaps, sizeof(d3dCaps));
     if (D3D_OK != m_d3d->GetDeviceCaps(
             D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &d3dCaps))
     {
         VERBOSE(VB_IMPORTANT, D3DERR + "Could not read adapter capabilities.");
-        return false;
     }
 
     D3DDISPLAYMODE d3ddm;
@@ -271,28 +269,59 @@ bool MythRenderD3D9::Create(QSize size, HWND window)
         return false;
     }
 
-    // TODO - check adaptor format is reasonable and try alternatives
     m_adaptor_fmt = d3ddm.Format;
-    bool default_ok = FormatSupported(m_videosurface_fmt, m_adaptor_fmt);
-    if (!default_ok)
-        m_videosurface_fmt = m_adaptor_fmt;
-
     VERBOSE(VB_GENERAL, D3DLOC +
-        QString("Default Adaptor Format %1 - Hardware YV12 to RGB %2 ")
-            .arg(toString(m_adaptor_fmt))
-            .arg(default_ok ? "supported" : "unsupported"));
-
-    // TODO - try alternative formats if necessary
-    if (!FormatSupported(m_surface_fmt, m_adaptor_fmt))
-        VERBOSE(VB_IMPORTANT, D3DERR + QString("%1 surface format not supported.")
-                                          .arg(toString(m_surface_fmt)));
+        QString("Default Adaptor Format %1.").arg(toString(m_adaptor_fmt)));
+
+    // Find the best h/w supported video surface format
+    static const D3DFORMAT vfmt[] = {
+        (D3DFORMAT)MAKEFOURCC('Y','V','1','2'),
+        D3DFMT_UYVY,
+        D3DFMT_YUY2,
+        (D3DFORMAT)MAKEFOURCC('I','Y','U','V'),
+        (D3DFORMAT)MAKEFOURCC('I','4','2','0'),
+        (D3DFORMAT)MAKEFOURCC('Y','V','1','6'),
+        D3DFMT_A8R8G8B8,
+        D3DFMT_X8R8G8B8,
+        D3DFMT_A8B8G8R8,
+        D3DFMT_X8B8G8R8
+    };
+    for (unsigned i = 0; i < sizeof vfmt / sizeof vfmt[0]; ++i) {
+        if (SUCCEEDED(m_d3d->CheckDeviceType(D3DADAPTER_DEFAULT,
+                D3DDEVTYPE_HAL, m_adaptor_fmt, vfmt[i], TRUE))) {
+            m_videosurface_fmt = vfmt[i];
+            break;
+        }
+    }
+    if (D3DFMT_UNKNOWN != m_videosurface_fmt)
+        VERBOSE(VB_GENERAL, D3DLOC +
+            QString("Best Video Surface Format %1.").arg(toString(m_videosurface_fmt)));
+    else
+        VERBOSE(VB_IMPORTANT, D3DERR + "Failed to agree video surface format");
+
+    // Find the best backing surface format
+    static const D3DFORMAT bfmt[] = {
+        D3DFMT_A8R8G8B8,
+        D3DFMT_X8R8G8B8,
+        D3DFMT_A8B8G8R8,
+        D3DFMT_X8B8G8R8,
+        D3DFMT_R8G8B8
+    };
+    for (unsigned i = 0; i < sizeof bfmt / sizeof bfmt[0]; ++i) {
+        if (FormatSupported(bfmt[i], m_adaptor_fmt)) {
+            m_surface_fmt = bfmt[i];
+            break;
+        }
+    }
+    if (D3DFMT_UNKNOWN != m_surface_fmt)
+        VERBOSE(VB_GENERAL, D3DLOC +
+            QString("Best surface format: %1.").arg(toString(m_surface_fmt)));
     else
-        VERBOSE(VB_GENERAL, D3DLOC + QString("Using %1 surface format.")
-                                          .arg(toString(m_surface_fmt)));
+        VERBOSE(VB_IMPORTANT, D3DERR + "Failed to agree surface format");
 
     D3DPRESENT_PARAMETERS d3dpp;
     ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
-    d3dpp.BackBufferFormat       = m_adaptor_fmt;
+    d3dpp.BackBufferFormat       = m_surface_fmt;
     d3dpp.hDeviceWindow          = window;
     d3dpp.Windowed               = TRUE;
     d3dpp.BackBufferWidth        = size.width();
@@ -301,16 +330,24 @@ bool MythRenderD3D9::Create(QSize size, HWND window)
     d3dpp.MultiSampleType        = D3DMULTISAMPLE_NONE;
     d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
     d3dpp.Flags                  = D3DPRESENTFLAG_VIDEO;
-    d3dpp.PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
+//    d3dpp.PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
 
     if (D3D_OK != m_d3d->CreateDevice(D3DADAPTER_DEFAULT,
-                                      D3DDEVTYPE_HAL, d3dpp.hDeviceWindow,
+                                      D3DDEVTYPE_HAL, NULL,
                                       D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                                       &d3dpp, &m_d3dDevice))
     {
         VERBOSE(VB_IMPORTANT, D3DERR + "Could not create the D3D device.");
         return false;
     }
+    VERBOSE(VB_GENERAL, D3DLOC + QString("Device backbuffer format: %1.")
+                                      .arg(toString(d3dpp.BackBufferFormat)));
+
+    if (D3DFMT_UNKNOWN == m_videosurface_fmt)
+        m_videosurface_fmt = d3dpp.BackBufferFormat;
+
+    if (D3DFMT_UNKNOWN == m_surface_fmt)
+        m_surface_fmt = d3dpp.BackBufferFormat;
 
     VERBOSE(VB_GENERAL, D3DLOC +
                QString("Hardware YV12 to RGB conversion %1.")
@@ -742,22 +779,24 @@ bool MythRenderD3D9::UpdateSurface(IDirect3DSurface9 *surface,
         return false;
 
     D3DFORMAT format = m_surfaces[surface].m_fmt;
-    if (format == D3DFMT_A8R8G8B8)
+    switch (format)
     {
-        int i;
+    case D3DFMT_A8R8G8B8:
+    case D3DFMT_X8R8G8B8:
+        {
         uint pitch = image->width() << 2;
         uint8_t *dst = buf;
         uint8_t *src = (uint8_t*)image->bits();
-        for (i = 0; i < image->height(); i++)
+        for (int i = 0; i < image->height(); i++)
         {
             memcpy(dst, src, pitch);
             dst += d3dpitch;
             src += pitch;
-        }
-    }
-    else
-    {
+        }}
+        break;
+    default:
         VERBOSE(VB_IMPORTANT, D3DERR + "Surface format not supported.");
+        break;
     }
 
     ReleaseBuffer(surface);
